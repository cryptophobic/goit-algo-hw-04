# Домашнє завдання до теми “Алгоритми сортування”


Щоб порівняти три алгоритми сортування — злиттям, вставками та Timsort — за часом виконання, спочатку розглянемо їхні теоретичні оцінки складності, а потім проведемо емпіричний аналіз з використанням модуля timeit для вимірювання часу виконання кожного алгоритму на різних наборах даних.

Теоретична оцінка складності:
## Сортування вставками (Insertion Sort):

- Найгірший випадок (O): O(n²)
- Середній випадок: O(n²)
- Найкращий випадок: O(n) (якщо масив майже відсортований)
- Сортування вставками працює добре на невеликих наборах даних або майже відсортованих масивах, але його складність зростає квадратично на великих масивах.

## Сортування злиттям (Merge Sort):

- Найгірший випадок (O): O(n log n)
- Середній випадок: O(n log n)
- Найкращий випадок: O(n log n)
- Це стабільний алгоритм із гарантованою складністю O(n log n), що робить його ефективним на великих наборах даних.

## Timsort:

- Найгірший випадок (O): O(n log n)
- Середній випадок: O(n log n)
- Найкращий випадок: O(n)
- Timsort є гібридним алгоритмом, який поєднує сортування злиттям і вставками. Він використовує сортування вставками на малих частинах масиву, а сортування злиттям — на великих частинах. Завдяки цьому, в багатьох реальних сценаріях, він працює швидше, ніж чисте сортування злиттям.

## Емпіричний аналіз:
Щоб підтвердити ці оцінки на практиці, проведемо серію тестів на трьох алгоритмах, використовуючи різні розміри даних. Набори даних будуть складатися з:

- Випадкових чисел
- Вже відсортованих чисел
- Реверсно відсортованих чисел
- Використаємо модуль timeit для заміру часу виконання.

```bash
Data size: 1000
Random data:
Insertion Sort: 0.022311 seconds
Merge Sort: 0.001686 seconds
Timsort: 0.000099 seconds
Sorted data:
Insertion Sort: 0.000107 seconds
Merge Sort: 0.001347 seconds
Timsort: 0.000010 seconds
Reversed data:
Insertion Sort: 0.037773 seconds
Merge Sort: 0.001372 seconds
Timsort: 0.000010 seconds

Data size: 5000
Random data:
Insertion Sort: 0.598276 seconds
Merge Sort: 0.010809 seconds
Timsort: 0.000546 seconds
Sorted data:
Insertion Sort: 0.000603 seconds
Merge Sort: 0.008440 seconds
Timsort: 0.000046 seconds
Reversed data:
Insertion Sort: 1.117308 seconds
Merge Sort: 0.009325 seconds
Timsort: 0.000050 seconds

Data size: 10000
Random data:
Insertion Sort: 2.385684 seconds
Merge Sort: 0.022516 seconds
Timsort: 0.001226 seconds
Sorted data:
Insertion Sort: 0.001173 seconds
Merge Sort: 0.017891 seconds
Timsort: 0.000091 seconds
Reversed data:
Insertion Sort: 4.674847 seconds
Merge Sort: 0.017991 seconds
Timsort: 0.000091 seconds
```

## Аналіз результатів:
Сортування вставками повинно показати погані результати на великих та випадкових даних через свою квадратичну складність.
Сортування злиттям має продемонструвати стабільний час виконання на всіх типах даних, хоча воно, ймовірно, програє Timsort на вже відсортованих масивах.
Timsort показує свою ефективність завдяки оптимізації під реальні сценарії, особливо на відсортованих або частково відсортованих масивах.

## Висновок:
Поєднання сортування злиттям та вставками робить Timsort одним з найбільш ефективних алгоритмів для загальних цілей. Саме тому Python використовує його як вбудований метод сортування, і більшість програмістів віддають перевагу готовим функціям sorted і sort замість написання власних реалізацій.

_PS. На мою особисту думку, порівняння не може важатися сповненим сенсу. Тому що реалізація timsort виконується в модулях Python (імовірно написана на C) і вже скомпілбована та відтрансльована в бінарний код. Де, вирогідніше за все були використані спеціальні структури даних і ряд інших оптимізацій._
